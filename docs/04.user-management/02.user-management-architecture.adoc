== Architecture Overview

[NOTE]
.Work In Progress
===============================================
This section focuses on HOW the functionality is provisioned, and how the building blocks are connected to each other.
Each building block contains:

* Description of functionality
* Used technologies and Standards
* List of interactions with other Building Blocks
* List of exposed endpoints (indicating which are exposed at API Platform level)
===============================================

=== Login Service

The Login Service is an OIDC Provider that provides a ‘Login With’ service that allows the end-user to select their Identity Provider for purposes of authentication.

The Login Service is designed to support the onward forwarding of the authentication request through external identity services, which should be expected to include:

* EduGain
* GitHub
* Google
* Twitter
* Facebook
* LinkedIn
* Others (to be defined)

The Login Service must establish itself as a client (Relying Party) of all supported external IdPs, with appropriate trust relationships and support for their authentication flows.

The primary endpoints required to support the OIDC flows are as follows (these endpoints are taken, by example, from OKTA OIDC discovery metadata, https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/.well-known/openid-configuration):

authorization_endpoint (/authorize)::
To initiate the authentication, and to return the access tokens / code grant (depending on flow).

token_endpoint (/token)::
To exchange the code grant for the access tokens.

userinfo_endpoint (/userinfo)::
To obtain the user information ID token in accordance with the scopes requested in the authorization request.

jwks_uri (/keys)::
To obtain signing keys for Token validation purposes.

end_session_endpoint (/logout)::
To logout the user from the Login Service, i.e. clear session cookies etc. Although, given that the actual IdP is externalised from the Login Service, it would remain the case that any session cookies maintained by the external IdP would still be in place for a future authentication flow.

introspection_endpoint (/introspect)::
Used by clients to verify access tokens.

revocation_endpoint (/revoke)::
Used for (refresh) token revocation.

As described in section ‘Discovery’, the following endpoints relate to Discovery:

OIDC Discovery (/.well-known/openid-configuration)::
Dynamic discovery of OIDC endpoints by clients.

As described in section ‘Client Registration’, the following endpoints relate to Dynamic Client Registration:

registration_endpoint (/clients)::
Dynamic registration of clients (Authentication Agents).

As described in section ‘Federation’, the following endpoints relate to the establishment of a federation of collaborating Exploitation Platforms through a dynamic trust model:

/.well-known/openid-federation::
OIDC Federation API endpoint through which Entity Statements are published about itself and other entities (such as other Exploitation Platforms). See section ‘Federation’.

==== OIDC ID Token

The ID Token is a JWT that is returned to from the /userinfo endpoint of the Login Service. The returned OIDC ID Token has been signed (JWS) by the Login Service and thus results in a token that asserts a user’s authenticated identity with integrity, and non-repudiation.

==== OIDC Clients

Clients are Relying Parties that act on behalf of users accessing the services of the Exploitation Platform. They will either pre-emptively obtain their access token for required resources, or will attempt resource access and be redirected by exception to the OIDC Provider authentication flow.

In the case of a web application (browser hosted), the Implicit Flow would be used. In other cases, where possible, the Authorization Code Flow would be preferred.

The OIDC flows are initiated with the appropriate response_type (‘id_token token’ for Implicit Flow, ‘code’ for Authorization Code Flow) and scope of ‘oidc profile’.

At the successful conclusion of the flow the client receives the Access Token and ID Token. The Access Token is then used by the client as a Bearer token in its subsequent calls to access the EP resources.

==== Additional OIDC Capabilities

OpenID Connect provides some additional functionalities that are of interest in the context of the Common Architecture.

*OIDC Discovery*

Reference: https://openid.net/specs/openid-connect-discovery-1_0.html

OpenID Connect makes provision for two types of discovery:

. Discovery of the OpenID Provider Issuer based upon the user’s identifier
. Discovery of the OpenID Provider Configuration Information

In the case of our usage within the Exploitation Platform, type 1) is not application since the user’s ID comes from their ‘Home’ organisation and is not (necessarily) tied to an OpenID Connect Provider. Instead the Login Service must implement a discovery ‘flow’ in which the user is able to select the provider of their identity, as one that is supported by the Login Service deployment.

Regarding discovery type 2), the Login Service exposes an OIDC Provider interface, and this should support retrieval of OIDC Provider Configuration Information. Thus, OIDC Clients can utilise the discovery interface of the Login Service to exploit its services.

This is of most interest in the case of access to federated resources in other EPs, where a resource server in one EP may be acting as an OIDC client of the Login Service in another EP – in which case auto-discovery might be more attractive.

*Client Registration*

Reference: https://openid.net/specs/openid-connect-registration-1_0.html

The possibility exists for the OIDC Client (Login Service) to perform auto-registration with the Login Service, using OIDC Client Registration. In doing so the OIDC client obtains its Client ID and Secret.

This may be of interest in a couple of cases:

* The case of access to federated resources in other EPs, where a resource server in one EP may be acting as an OIDC client of the Login Service in another EP – in which case auto-client-registration might be of interest.
* The case where a common Login Service is deployed outside of the context of a given Exploitation Platform, acting as an IdP Proxy. In this case, the local Login Service deployed in each EP would register as an OIDC Client of the IdP Proxy.

==== SCIM Endpoints

[NOTE]
.Work In Progress
===============================================
This section will contain a description of SCIM and its the usage within the architecture.
===============================================

==== Interaction with other components

While the external interactions of the Login Service with client applications and End-Users are clearly stated (see figure <<img_iamOverviewFlow>>), this Building Block exposes several endpoints, mostly for their usage within the platform:

* SCIM Provider, allowing access to the back-end schema that stores information required to provide platform functionality.
* OIDC Provider, allowing authentication of SW components as trusted SCIM Clients.

*Interal usage of Endpoints*

Most of the other building blocks described in the User Management section will utilize the SCIM Endpoint for various purposes. In order to do so, they will be authenticated as trusted SCIM Clients, therefore requiring interaction with the exposed OIDC and UMA Endpoints.

[NOTE]
.Work In Progress
===============================================
Add image for client authentication
===============================================

=== Policy Decision Point
The Authorization flow is relevant to the following interfaces:

* PEP <-> PDP +
The PEP, acting as a filter for the access attempt on the resource, defers its authorization decision to the PDP.

* PDP <-> Other PDP +
Aspects of the authorization policy can be delegated from one PDP to another, e.g. to govern resource access through an administrative domain represented by a _Virtual Organisation_.

The approach (data model and protocol) for these two interfaces can be aligned - but is not yet defined in the Common Architecture. At this stage the candidate technologies to be investigated are:

* XACML (eXtensible Access Control Markup Language)
* UMA (User-Managed Access)

XACML and UMA can possibly be used together in an overall solution in which *XACML provides the policy language* through which rules are configured and *UMA provides the ‘protocol’ flows*.

==== XACML (eXtensible Access Control Markup Language)

XACML defines an architecture in which the access decision is separate from the point of use, and is thus consistent with the high-level IAM approach described in this design document. The XACML architecture framework describes a Request-Response protocol, and a policy language in which access policies are defined as rules comprising attributes. XACML additionally describes the process through which policies are evaluated, for example through _combining algorithms_ that mediate competing rules.

*XACML 3.0*

XACML 3.0 includes some additional aspects that are of interest to our proposed IAM approach. Namely:

Administrative delegation::
The delegation mechanism is used to support decentralized administration of access policies. It allows an authority (delegator) to delegate all or parts of its own authority, (or someone else's authority), to another user (delegate) without any need to involve modification of the root policy.

JSON Request/Response Profile::
JSON bindings for the request/response messages between the PEP and the PDP - as an alternative to the core XML message definitions.

REST Profile::
Providing REST semantics for the PEP/PDP interface.

*GeoXACML*

GeoXACML is standardised by the OGC to provide a geo-specific extension to XACML 2.0. GeoXACML provides support for spatial data types and spatial authorization decision functions. Those data types and functions can be used to define additional spatial constraints for XACML based policies.

[NOTE]
.XACML Related Technologies
===============================================
The following items represent some interesting existing implementations that may be considered as a possible basis for a reference implementation of the Common Architecture.

AuthzForce PDP::
An authorization service providing authorization policy decision evaluation and policy administration.
Provides an API to get authorization decisions based on authorization policies, and authorization requests from PEPs. The API follows the REST architecture style, and complies with XACML v3.0.
* Project page: https://fimac.m-iti.org/6d.php
* Documentation: https://authzforce-ce-fiware.readthedocs.io/en/latest/

geoPDP::
GeoXACML for AuthzForce PDP - extends the AuthZForce PDP implementation with a Geometry data type and related functions as specified in the OGC Implementation Standard GeoXACML 1.0.1.
* GitHub page: https://github.com/securedimensions/authzforce-geoxacml-basic
* geoPDP Docker: https://github.com/securedimensions/geopdp-docker

geoPEP::
Related to the geoPDP is the geoPEP that delivers a PEP as an Apache2 reverse proxy - implemented as an Apache2 module - interfacing with the geoPDP for the authorization decisions.
* geoPEP Docker: https://github.com/securedimensions/geopep-apache2-reverse-proxy
===============================================

==== UMA (User-Managed Access)

User-Managed Access (UMA) is a profile of OAuth 2.0. UMA defines how resource owners can control protected-resource access by clients operated by arbitrary requesting parties, where the resources reside on any number of resource servers, and where a centralized authorization server governs access based on resource owner policies. Resource owners configure authorization servers with access policies that serve as asynchronous authorization grants.

*UMA Main Actors*

The main UMA actors are briefly summarised as follows:

Resource Owner (RO)::
The "user" and the owner of the resource who defines the access authorization - typically the end-user, but it can also be a corporation or other legal person.

Client::
An application making protected resource requests with the Resource Owner's authorization and on the Requesting Party's behalf - typically a web or native application.

Resource Server (RS)::
The custodian of the resource - typically a service through which access to the resource is gained.

Authorization Server (AS)::
A server that issues _Authorization Data_ and RPTs to a client and protects resources managed at a resource server. Authorization Data is associated with an RPT to enable some combination of the Authorization Server and Resource Server to determine the correct extent of access to allow to a Client.

Requesting Party (RqP)::
The entity that uses a Client to seek access to a protected resource. May be the Resource Owner, or can be some other third party entity requesting access to the resource.

The software components that fill the roles of UMA authorization servers, resource servers, and clients respectively are intended to work in an interoperable fashion when each is operated by an independent party (for example, different organizations).

[quote, Wikipedia, https://en.wikipedia.org/wiki/User-Managed_Access]
____
In a typical OAuth flow, a human resource owner (RO) operating a client application is redirected to an authorization server (AS) to log in and consent to the issuance of an access token so that the client application can gain access to the resource server (RS) on the RO’s behalf in future, likely in a scoped (limited) fashion. The RS and AS are in all likelihood operating within the same security domain, and any communication between them is not standardized by the main OAuth specification.

UMA adds three main concepts and corresponding structures and flows. First, it defines a standardized API at the AS, called the protection API, that the RS speaks to; this enables multiple RS’s to communicate with one AS and vice versa, and because the API is itself secured with OAuth, allows for formal trust establishment between each pair. This also allows an AS to present an RO with a centralized user interface. Second, UMA defines a formal notion of a requesting party (RqP) that is autonomous from an RO, enabling party-to-party sharing and delegation of access authorization. An RO need not consent to token issuance at run time but can set policy at an AS, allowing an RqP to attempt access asynchronously. Third, UMA enables access attempts to result in successful issuance of tokens associated with authorization data based on a process of trust elevation in the RqP, for example, gathering identity claims or other claims from them.
____

*UMA Phases*

UMA describes three main phases:

[.strong]
. *Protect Resource* +
The Resource Owner, who manages online resources at the Resource Server, introduces it to the Authorization Server so that the latter can begin protecting the resources. To accomplish this, the Authorization Server presents a *_Protection API_* to the resource server. This API is protected by OAuth (or an OAuth-based authentication protocol) and requires a *_Protection API Token (PAT)_* for access. Out of band, the Resource Owner configures the Authorization Server with policies associated with the resource sets that the resource registers for protection.

. *Get Authorization* +
The Client approaches the Resource Server seeking access to an UMA-protected resource. In order to access it successfully, the Client must first use the Authorization Server's *_Authorization API_* to obtain authorization data and a *_Requesting Party token (RPT)_* on behalf of its Requesting Party, and the Requesting Party may need to undergo a process of trust elevation, for example, supplying identity claims. The API is protected by OAuth (or an OAuth-based authentication protocol) and requires an *_Authorization API Token (AAT)_* for access.

. *Access Resource* +
The Client successfully presents to the Resource Server an RPT that has sufficient authorization data associated with it, gaining access to the desired resource.

*UMA Terminology*

To elaborate the descriptions of these phases, UMA employs a set of terminology that is summarised below...

TERMS::

* *Policy* +
The configuration parameters of an authorization server that effect resource access management - typically defined is terms of "subjects", "verbs" and "objects". Policy configuration takes place between the resource owner and the authorization server.

* *Claim* +
A statement of the value or values of one or more identity attributes of a Requesting Party. A Requesting Party may need to provide claims to an Authorization Server in order to gain permission for access to a protected resource.

* *Resource Set* +
One or more protected resources that a resource server manages as a set - thus, a Resource Set is the "object" being protected.

* *Scope* +
A bounded extent of access that is possible to perform on a Resource Set - a scope is one of the potentially many "verbs" that can logically apply to a Resource Set ("object").

* *Permission* +
A scope of access over a particular Resource Set at a particular Resource Server that is being requested by, or granted to, a Requesting Party. Thus, a Permission is an entitlement that includes a "subject" (Requesting Party), "verbs" (one or more Scopes of access), and an "object" (Resource Set).

* *Permission Ticket* +
A correlation handle that is conveyed from an Authorization Server to a Resource Server, from a Resource Server to a Client, and ultimately from a Client back to an Authorization Server, to enable the Authorization Server to assess the correct policies to apply to a request for Authorization Data.

* *Authorization Data* +
Data (e.g. a Permission) associated with an RPT that enables some combination of the Authorization Server and Resource Server to determine the correct extent of access to allow to a Client.

TOKENS::

* *Requesting Party Token (RPT)* +
An UMA access token associated with a set of Authorization Data, used by the Client to gain access to protected resources at the Resource Server.

* *Authorization API Token (AAT)* +
An OAuth access token with the scope *_uma_authorization_*, used by the Client at the Authorization API _'RPT Endpoint'_. An AAT binds a Requesting Party, a Client being used by that party, and an Authorization Server that protects resources this Client is seeking access to on this Requesting Party's behalf. The issuance of an AAT represents the approval of this Requesting Party for this Client to engage with this Authorization Server to supply claims, ask for authorization, and perform any other tasks needed for obtaining authorization for access to resources at all Resource Servers that use this Authorization Server.

* *Protection API Token (PAT)* +
An OAuth access token with the scope *_uma_protection_*, used by the Resource Server at the Protection API, consisting of the _'Resource Set Registration'_, _'Permission Registration'_, and _'Token Introspection'_ endpoints. A PAT binds a Resource Owner, a Resource Server the owner uses for resource management, and an Authorization Server the owner uses for protection of resources at this Resource Server. The issuance of a PAT represents the approval of the Resource Owner for this Resource Server to use this Authorization Server for protecting some or all of the resources belonging to this Resource Owner.

ENDPOINTS::

* *Authorization API*
Requires access token with _uma_authorization_ scope (AAT). An entity that can acquire an access token with this scope is by definition a Client.
** *RPT Endpoint* +
An endpoint at the Authorization Server that issues RPTs and Authorization Data to the Client.

* *Protection API* +
Requires access token with _uma_protection_ scope (PAT). An entity that can acquire an access token with this scope is by definition a Resource Server.
** *Resource Set Registration Endpoint* +
An endpoint at the Authorization Server that allows the Resource Server to register Resource Sets.
** *Permission Registration Endpoint* +
An endpoint at the Authorization Server that allows the Resource Server to request Permission Tickets.
** *Token Introspection Endpoint* +
An endpoint at the Authorization Server that allows the Resource Server to query the status of an RPT and its associated Authorization Data.

*Resource Protection*

The resource owner, resource server, and authorization server perform the following high-level actions to put resources under protection:

. The Authorization Server issues client credentials to the resource server, (either dynamically or statically)
. The Resource Server acquires a PAT from the Authorization Server
. The Resource Server registers any Resource Sets with the Authorization Server for which it intends to outsource protection, using the Resource Set Registration Endpoint of the Protection API

[yellow-background]#*[COMMENT(RAC): What is the relationship between this and the Resource API (/resources) offered by the PEP?]*#

*Access Resource*

An Authorization Server orchestrates and controls Clients' access on their Requesting Parties' behalf to a Resource Owner's protected resources at a Resource Server, under conditions specified by that Resource Owner through policy.

The process of getting authorization and accessing a resource always begins with the Client attempting access at a protected resource endpoint at the Resource Server.

If the Client's attempt has a valid RPT with sufficient Authorization Data, the Resource Owner's policies have been met for access to the protected resource, and hence access is granted. See <<img_umaAccessResource>>.

[.text-center]
[#img_umaAccessResource,reftext='{figure-caption} {counter:figure-num}']
.UMA Access Resource (Success)
[plantuml, uma-access-resource, png]
....
include::include/uma-access-resource.wsd[]
....

*Resource Server Register Permission*

If the Client's request at the protected resource has no RPT, or has an invalid RPT or insufficient Authorization Data associated with the RPT as determined through RPT status checking, the Resource Server registers a requested permission with the relevant Authorization Server, and responds to the Client with the resulting Permission Ticket and the Authorization Server's location. The extent of the requested permission MUST suffice for the extent of the Client's access attempt at that resource. The PAT provided in the API request enables the Authorization Server to map the requested permission to the appropriate Resource Owner. The Authorization Server returns a Permission Ticket in its response for the Resource Server to give to the Client that represents the same extent of requested access that the Resource Server registered. See <<img_umaRegisterPermission>>.

[.text-center]
[#img_umaRegisterPermission,reftext='{figure-caption} {counter:figure-num}']
.UMA Resource Server Register Permission
[plantuml, uma-register-permission, png]
....
include::include/uma-register-permission.wsd[]
....

*Client Request Authorization*

In order to access a protected resource successfully, a client needs to present a valid RPT with sufficient authorization data. The client uses the authorization API to acquire an RPT and to ask for authorization data, providing the permission ticket it received from the resource server.

The authorization server uses the permission ticket to look up the details of the previously registered requested permission, maps the requested permission to operative resource owner policies based on the resource set identifier and scopes associated with it, potentially requests additional information and receives additional information such as claims, and ultimately responds positively or negatively to the request for authorization data. *The authorization server bases the issuance of authorization data on resource owner policies. Thus, these policies function as authorization that has been granted ahead of time.* See <<img_umaClientRequestAuthorization>>.

[.text-center]
[#img_umaClientRequestAuthorization,reftext='{figure-caption} {counter:figure-num}']
.UMA Client Request Authorization
[plantuml, uma-client-request-authorization, png]
....
include::include/uma-client-request-authorization.wsd[]
....

Optionally, the Authorization Server may need additional information in order to determine whether the Client is authorized to have this authorization data. The Authorization Server response indicates "need_info" including one or more sub-properties with hints about the nature of further required information. The Client then has the opportunity to continue seeking authorization by engaging in follow-on flows with the authorization server, either directly or through redirection of an end-user Requesting Party.


[[policyAPI]]
==== Policy API

The PDP exposes a REST API that allows to register, remove and update policy documents within the Authorization architecture. These policy documents are utilized during policy decision checks (using XACML compliant requests and responses).

Any Resource Server can dynamically interact with the API to assign specific policies to resources during the execution of their internal processes, or they can delegate this functionality to Resource Owners, and let them consume the API as they see fit.

The following example showcases how a Resource Owner can have its process deployed, dynamically registered and protected by an ADES component:

[.text-center]
[#img_policyAPI,reftext='{figure-caption} {counter:figure-num}']
.Dynamic Resource Protection through a Policy API
[plantuml, policy-management, png]
....
include::include/policy-management.wsd[]
....


==== Interaction with other components

While the external interactions of the Policy Decision Point with client applications and End-Users follow the UMA Flow described above, this Building Block also interacts directly with other Building Blocks for several purposes.

*Internal usage of Endpoints*

Interaction with other Building Blocks can be found in the following list:

* PDP to Resource Server (i.e ADES): Dynamic Protection of Resources through Policy Management. Any new resource within the Platform can be dynamically protected by any component through M2M interactions.

* PEP to PDP requests: Resource ID resolution. If a request for access is performed against the Policy Enforcement Point, the PEP queries the PDP for a unique resource identification and generates an access request ticket that Client Applications will be able to use to generate the corresponding access tokens.

* PDP to external PDP requests: external policy resolution. Whenever a policy decision requires external checks, the PDP will perform queries against these external PDP Services and integrate the response within the overall policy resolution procedure.

* PDP to License Manager requests: license-based policies. In the case that a defined policy contains restrictions based on license agreement or licence limits of use, the PDP will perform checks against the License Management API, to ensure that corresponding criteria are met.

* PDP to Billing Service requests: bugdets and inter-platform payments. If a requests contains a billing-based policy that imposes restrictions based on billing identity or requires accounting of usage for potential inter-platform payments, the PDP will utilize the Billing Service to perform policy checks.

=== Policy Enforcement Point
==== Overview

The PEP (acting on behalf of the resource server) receives the client request to access the protected resource. In the case that the access requires an authenticated user, then the PEP expects that the request includes a valid access token.


==== Reverse Proxy Functionality

The PEP follows the logic:

* The PEP checks with the PDP whether an authenticated user is required for access
* If no authenticated user is required then the request can continue (pending authorization) as an 'anonymous' user
* If access requires an authenticated user then
** If the access token is not present then no user is logged in, so the request should be redirected to the /authorize endpoint (HTTP redirect)
** If the access token is present, then it should be validated with the Login Service (direct call), as described below
** If the access token validation completes successfully then the request can continue (pending authorization), with the user identity provided by the ID Token received during token validation
** If the token is invalid, then the request should be redirected to the /authorize endpoint (HTTP redirect)

In addition to this, the PEP also encodes two sets of key information as part of request headers, when propagating the request to the underlying Resource Server:

* End-User Context: an Authorization Bearer header containing the ID Token generated during the access request.
* Policy Context: a reference to a temporal, local repository of policy check results associated to the on-going request. The following image showcases the interactions with an hypothetical ADES component:


[.text-center]
[#img_policyContext,reftext='{figure-caption} {counter:figure-num}']
.Policy Context Propagation through PEP protected requests.
[plantuml, policy-context-propagation, png]
....
include::include/policy-context-propagation.wsd[]
....

[yellow-background]#*[COMMENT(RAC): Is this an example of 'Policy Context Propagation' previously mentioned?]*#

==== Access Token Validation

The PEP validates the access token by using it as a Bearer token in a request to the Login Service’s /userinfo endpoint. A successful response has two outcomes:

* Confirms the validity of the access token from the point-of-view of the Login Service that issued it
* Provides an ID Token for the user that provides the information required to uniquely identify the user within the EP and utilise this identity within the subsequent policy decision made by the PDP

The ID Token is a JWT that has been signed by the Login Service. Using the jwks (see section ‘OIDC Federation’) endpoint of the Login Service, the PEP is able to obtain the necessary keys to validate the signature of the ID Token. This provides the full user context for the resource access.

[[resourceAPI]]
==== Resource API

The PEP exposes a REST API that allows to register, remove and update resource references within the Authorization architecture. These resource references are used to perform the Proxying functionality (enforcing authorization) when generating access tickets and enable Policy Decisions to take place on the Policy Decision Points.

Any Resource Server can dynamically interact with the API to register resources during the execution of their internal processes, or they can delegate protection of resources directly to Resource Owners, and let them consume the API as they see fit.

The following example showcases how a Resource Owner can have its process deployed and dynamically registered by an ADES component:

[.text-center]
[#img_resourceAPI,reftext='{figure-caption} {counter:figure-num}']
.Dynamic Resource Registration through a Resource API
[plantuml, resource-protection, png]
....
include::include/resource-protection.wsd[]
....

[yellow-background]#*[COMMENT(RAC): Is this equivalent to the UMA 'Resource Protection' API?]*#

==== Interaction with other components

The Policy Enforcemnt Point mainly interacts with both Client Applications and Services and its meant to ensure that the proper policies are enforced during access. This not only requires interaction with both Client and Services, but also requires interaction with internal components.

*Internal usage of Endpoints*

The Policy Enforcement point requires two interactions with other Building Blocks:

* PEP to Resource Server (i.e ADES): Dynamic Registration of Resources. If a new resource is generated by interacting with a Resource Server (such as a processing environment), the resulting asset can be registered dynamically as a resource.

* PEP to PDP requests: Resource ID resolution. If a request for access is performed against the Policy Enforcement Point, the PEP queries the PDP for a unique resource identification and generates an access request ticket that Client Applications will be able to use to generate the corresponding access tokens.

* PEP to Login Service requests: Authentication as Resource Server. Given that the Policy Enforcement Point acts as the facade of any given service, it is necessary for the PEP to act as a Resource Server:

** Interaction with OIDC Endpoints in order to authenticate as a client application and acquire Resource Server priviledges.
** Interaction with UMA Endpoints in order to perform ticket generation and token instrospection requests

=== Billing Service

A Billing Service will operate within the platform which receives reports of billing events from other components. These are recorded against the relevant billing identity. Billing events have arbitrary attributes defined in them, which the billing service does not interpret (but are sufficient for the pricing engine, see below), a transaction ID identifying the original user action which caused it, and enough additional information for display to the user. Some example billing events might be:

* 1 hour of extra-large-vm
* 12 CPU-hours of container execution time
* licence for satellite image x
* execution cost of $x from federated platform y

Individual components decide when to generate billing events - for example, compute cost billing events may be generated every hour. Billing events may have a start and end or a single time - events with a start and end may be split to keep them within a single billing window.

The Billing Service can generate reports for the user. This may involve combining billing events in to line items, such as consolidating VM use in to the number of hours so far this month.

The Billing Service will generate bills for each billing window by pricing complete windows. Fixed prices are assigned and recorded at this point. It may also keep track of and, where supported by the platform, initiate payments.

To support the PDP and other services, the Billing Service may be required to periodically assess the account’s standing and make decisions on the acceptibility of resource use. This depends on the billing model in use but could involve checking that credits are not exhausted, checking that a reasonable credit limit has not been reached and the detection of potentially fraudulent behaviour. An account which is no longer in good standing may result in API requests for resource use being denied, or it may result in termination messages being sent in response to billing events.

Where billing events are reported in another currency, as may happen with federated resource use, the Billing Service must determine the time and rate for currency exchange.


==== Interaction with other components

The Billing Service mainly exposes endpoints in order to ingest Billing Events and to generate Billing Window Reports. These requests are expected to originate from Platform Services.

*Interal usage of Endpoints*

On the other hand, the Billing Service requires three main interactions with other Building Blocks:

* PDP to Billing Service requests: billing-based policies.
* Billing Service to Login Service/User Profile requests: handling of billing Identities. The Billing Service may require access to specific billing attributes that reside in the User Profile back-end. These interactions require:

** Usage of OIDC Endpoints in order to authenticate as a client application and acquire the necessary priviledges to interact, using SCIM, with the back-end storing user information.
** Interaction with SCIM Endpoints in order to perform simple billing identity checks and changes on potential credit attributes.

* Billing Service to Pricing Engine: on-demand price rate calculations. Whenever a the Billing Service requires calculation of costs (either for Policy resolution or Billing Window Report generation), it is possible to query the Pricing Engine endpoints in order to acquire this information.

=== Pricing Engine

To maximize reusability price calculation is separated in to a different service (but not necessarily a different address space). Given access to a price database describing current, future and past configured prices, a Pricing Engine is otherwise stateless.

==== Interaction with other components

The Pricing Engine mainly supports Billing Service functionality:

* Given a list of billing events or consolidated line items within a pricing window return calculated rates and prices for each one. For some pricing models this may involve multiple charges for each item or may contain blended rates/prices.
* Return estimated prices for estimated resource use.
* Where a platform wished to provide such a service to users, return price information and estimated prices in response to API requests.
* Given a commercial licence billing event, calculate the charge to the user, the credit to the Licenser and the platform fee.

=== License Manager

==== Interaction with other components

The License Manager exposes a License Management API that could potentially be utilized by agents outside of the Platform, but its main purpose is to enhance the functionality of the rest of the Building Blocks. It has also the potential to genrate Billing Events that can be pushed to Billing Service endpoints.

*Interal usage of Endpoints*

* License Manager to Billing Service: generation of license-based billing events. Whenever usage of a License takes place, the License Manager can generate a billing event that will be pushed to the Billing Service API.
* License Manager to Login Service/User Profile requests: handling of license information. The License Manager may require access to specific end-user attributes that reside in the User Profile back-end. These interactions require:

** Usage of OIDC Endpoints in order to authenticate as a client application and acquire the necessary priviledges to interact, using SCIM, with the back-end storing user information.
** Interaction with SCIM Endpoints in order to perform simple license checks and extend end-user information with references to Service Licenses.

=== User Profile

[NOTE]
.Work In Progress
===============================================
TBD: Approach to User Profile Building Block
* Used Technologies and Standards
* Interactions with other building blocks
* Exposed Endpoints
===============================================
